angular.module('cr.acl', [])
    .constant('cr-acl.config', {
        'redirect': 'unauthorized',
        'roles': {
            'ROLE_GUEST': [],
            'ROLE_USER': ['ROLE_GUEST']
        }
    })
    .provider('crAcl', ['cr-acl.config', function (config) {
        var self = {};
        self.roles = config.roles;
        self.redirect = config.redirect;

        this.$get = ['$q', '$rootScope', '$injector', function ($q, $rootScope, $injector) {
            var crAcl = {};

            /**
             * Configure roles tree
             * @param {array} roles
             */
            crAcl.setInheritanceRoles = function (roles) {
                angular.forEach(roles, function (inheritance, roleName) {
                    if (roleName === 'ROLE_USER' && roleName === 'ROLE_GUEST') {
                        throw roleName + ' is a reserved world because is a father of ROLE, you can not override it';
                    }
                    self.roles[roleName] = inheritance;
                });
            };

            /**
             * Set route name for redirect after unauthorized operation
             */
            crAcl.setRedirect = function (redirectStateName) {
                self.redirect = redirectStateName;
            };

            /**
             * Set Role
             * @param {string} role
             */
            crAcl.setRole = function (role) {
                self.identityRole = role;
            };

            /**
             * Get all Roles
             */
            crAcl.getRoles = function () {
                return self.roles;
            };

            /**
             * Return your role
             * @return string
             */
            crAcl.getRole = function () {
                if (self.identityRole === undefined) {
                    return 'ROLE_GUEST';
                }
                return self.identityRole;
            };

            /**
             * Your role is granted for this route?
             * @param {string} identityRole
             * @param {array} stateRolesGranted
             * @return bool
             */
            crAcl.isGranted = function (identityRole, stateRolesGranted) {
                var isRoleGranted = function (theRole, grantedRoles) {
                    // Check if current role is one of the directly allowed roles
                    if (grantedRoles.indexOf(theRole) !== -1) {
                        return true;
                    }

                    // Recursively check inherited roles
                    for (var i in self.roles[theRole]) {
                        if (isRoleGranted(self.roles[theRole][i], grantedRoles)) {
                            return true;
                        }
                    }

                    return false;
                };

                if ((identityRole in self.roles) === false) {
                    throw 'This role[' + identityRole + '] not exist into InheritanceRoles declaration';
                }

                return isRoleGranted(identityRole, stateRolesGranted);
            };

            var afterChangeStart = function (event, toState, toParams, fromState, fromParams) {
                if (!toState.data || !toState.data.is_granted) {
                    return crAcl;
                }
                if (toState.data.is_granted[0] === '*') {
                    return crAcl;
                }
                var is_allowed = (toState.data.is_granted !== undefined) ? toState.data.is_granted : ['ROLE_GUEST'];
                return crAcl.isGranted(crAcl.getRole(), is_allowed);
            };

            $rootScope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams) {
                $injector.invoke(['$state', function ($state) {
                    var isGranted = afterChangeStart(event, toState, toParams, fromState, fromParams);

                    if (!isGranted && self.redirect !== false) {
                        event.preventDefault();
                        if (self.redirect !== toState.name) {
                            $state.go(self.redirect);
                        }
                    }
                }]);
            });

            $rootScope.$on('$routeChangeStart', function (event, toState, toParams, fromState, fromParams) {
                $injector.invoke(['$location', function ($location) {
                    var isGranted = afterChangeStart(event, toState, toParams, fromState, fromParams);

                    if (!isGranted && self.redirect !== false) {
                        event.preventDefault();
                        if (self.redirect !== toState.name) {
                            $location.path(self.redirect);
                        }
                    }
                }]);
            });

            return crAcl;

        }];
    }])
    .directive('crGranted', ['crAcl', '$animate', function (acl, $animate) {
        return {
            restrict: 'A',
            transclude: 'element',
            terminal: true,
            link: function (scope, elem, attr, ctrl, $transclude) {
                var content = false;
                $transclude(function (clone) {
                    clone[clone.length++] = document.createComment(' end crGranted: ' + attr.crGranted + ' ');
                    content = clone;
                });

                scope.$watch(function () {
                    return acl.getRole();
                }, function () {
                    if (shouldBeShown()) {
                        $animate.enter(content, elem.parent(), elem);
                    } else if (content) {
                        content.remove();
                    }
                });

                var shouldBeShown = function () {
                    var allowedRoles = attr.crGranted.split(','),
                        currentRole = acl.getRole();

                    return acl.isGranted(currentRole, allowedRoles);
                };
            }
        };
    }]);
